Aluno: Alexandre Nobuharu Sato, Jabaquara-SP 17/02/2021

Questões para o pset5 do curso CC50 (CS50 Harvard)

Leia um pouco sobre os formatos de arquivo BMP, GIF, JPEG, PNG.Depois, em pset5/questions.txt, responda as
questões abaixo:

	0. Quantas cores diferentes cada formato suporta?
	1. Qual destes formatos suporta animação?
	2. Qual é a diferença entre a compressão com perdas e sem perdas?
	3. Qual destes formatos é comprimido com perdas?


	0. Quantas cores diferentes cada formato suporta?
	R:BMP:podem variar de preto e branco (1 bit por pixel) de até 24 bits de cores (16,7 milhões de cores);
	  GIF:GIF só trabalha com esquema de 256 cores (8 bits), por isso não é muito comum em fotografias;
	  JPEG: 16 milhões de cores;
	  PNG: Até 16 milhões de cores.
	(Fonte: https://www.techtudo.com.br/artigos/noticia/2012/07/entenda-os-formatos-dos-arquivos-de-imagem.html)

	1. Qual destes formatos suporta animação?
	R: GIF e PNG.

	2. Qual é a diferença entre a compressão com perdas e sem perdas?
	R: A possibilidade de recuperação exata dos dados originais após o processo de descompressão.

	3. Qual destes formatos é comprimido com perdas?
	R: GIF, JPEG-DTC.


4.O que acontece, tecnicamente falando, quando um arquivo é removido de um sistema de arquivos FAT?
R: Os dados do arquivo em sí não são apagados da memória, o que acontece é que o sistema simplesmente "esquece" que aqueles 
   endereços de memória têm finalidades específicas inerentes àquele arquivo removido e agora estão disponíveis para qualquer
   outra utilização. Então remover um arquivo em um sistema FAT não significa "limpar o espaço" mas sim "deixar disponível
   para outra utilização".

5.O que alguém como você pode fazer para garantir (com alta probabilidade) que os arquivos que
  você excluir não poderão ser recuperados?
R: Sobreescrever a memória utilizada por aquele arquivo no mínimo duas vezes com dados aleatórios.
	
6. O que é stdint.h?
R: É um arquivo de cabeçalho utilizado para se determinar o tipo de inteiro e seu respectivo tamanho que será utilizado 
   em cada variável.

7. Porque se usa uint8_t, uint32_t, int32_t e uint16_t em um programa?
R: Para permitir que uma implementação seja compatível com tipos de hardwares diferentes, 
   e também para garantir que os inteiros sejam representados exatamente com N bits.

8. Quantos bytes tem um BYTE, uma DWORD, um LONG e uma WORD, respectivamente?
R: BYTE = 1 byte, DWORD = 4 bytes, LONG = (3 bytes + 7 bits + 1 bit para o sinal) e WORD = 2 bytes.

9. O que (em ASCII, decimal ou hexadecimal) devem ser os dois primeiros bytes de qualquer arquivo BMP?
R: ASCII: BM	       decimal: 19778		hexadecimal: 0x4d42

10. Qual é a diferença entre bfSize e biSize?
R: bfSize é o tamanho do arquivo todo, biSize é o tamanho do BITMAPINFOHEADER
	Fonte: https://stackoverflow.com/questions/25713117/what-is-the-difference-between-bisizeimage-bisize-and-bfsize

11. O que significa se biHeight for negativo?
R: Significa que imagem foi gerada de cima para baixo (início do buffer à esquerda).

12. Que campo em BITMAPINFOHEADER especifica a cor do BMP (bits por pixel)?
R: biBitCount.

13. Por que fopen pode retornar NULL em copy.c:32?
R: Por alguma razão o programa não conseguiu acessar o documento informado em argv[1], o nome pode ter sido escrito errado,
   o arquivo não existe, ou o arquivo existe e não tem permissão para abri-lo, etc. A maneira mais correta de ter certeza
   é consultando o código "errno".

14. Porque é que o terceiro argumento de fread é sempre 1 em nosso código?
R: O terceiro argumento de fread indica quantos alementos de dados devem ser lidos. A função fread retorna a quantidade de 
   elementos que conseguiu ler. O terceiro argumento é 1 porque precisamos ter certeza que a função fread conseguiu ler um
   bloco inteiro de dados, pois uma leitura parcial em pequenos pacotes não nos interessa nesta situação.

15. Qual o valor que copy.c:69 atribui a padding se bi.biWidth é 3?
R: Tendo em vista que o padding completa cada linha da imagem cuja quantidade de bytes não seja multíplo de 4 com bytes "zerados"
   e que o tamanho de RGBTRIPLE é 3 bytes
   então bi.biWidth * sizeof(RGBTRIPLE) = ?
	     3	    *	3		= 9 (serão necessários 9 bytes para construir cada linha da imagem de 3 pixel)

  logo o multíplo de 4 mais próximo acima de 9 é o 12, então o padding = 12 - 9
  concluindo quando bi.biWidht é 3 então valor de padding será: 3 (três) bytes, pois 12 - 9 = 3.	

16. O que é que fseek faz?
17. O que é SEEK_CUR? 
