Pset 6 do curso cc50, Alexandre Nobuharu Sato, Ribeirão Pires - SP, 24 de abril de 2021.


0. O que é pneumoultramicroscopicossilicovulcanoconiose?
R: É a maior palavra de língua portuguesa, com 44 letras.


1. De acordo com a sua página do manual, o que getrusage fazer?
R: Ela retorna a utilização de recursos pelo chamador e sua sintaxe
é int getrusage(int who, struct rusage *usage); onde who pode ser
 RUSAGE_SELF
 RUSAGE_CHILDREN
 RUSAGE_THREAD.


2. De acordo com a mesma página, quantos membros tem uma variável do tipo struct rusage?
R: 16 membros:

           struct rusage {
               struct timeval ru_utime; /* user CPU time used */
               struct timeval ru_stime; /* system CPU time used */
               long   ru_maxrss;        /* maximum resident set size */
               long   ru_ixrss;         /* integral shared memory size */
               long   ru_idrss;         /* integral unshared data size */
               long   ru_isrss;         /* integral unshared stack size */
               long   ru_minflt;        /* page reclaims (soft page faults) */
               long   ru_majflt;        /* page faults (hard page faults) */
               long   ru_nswap;         /* swaps */
               long   ru_inblock;       /* block input operations */
               long   ru_oublock;       /* block output operations */
               long   ru_msgsnd;        /* IPC messages sent */
               long   ru_msgrcv;        /* IPC messages received */
               long   ru_nsignals;      /* signals received */
               long   ru_nvcsw;         /* voluntary context switches */
               long   ru_nivcsw;        /* involuntary context switches */
           };


3. Porque você acha que passamos before e after por referência (em vez de por valor) para
calculate, mesmo que nós não estejamos mudando os seus conteúdos?
R: Eu acho que é para maximizar a eficiência da utilização de recursos, tais como

Tempo de desenvolvimento: É mais simples codificar passando a referência da memória de uma estrutura 
completa do que passar cada um de seus membros utilizando argumentos na função, neste exercício por 
exemplo teríamos que passar no mínimo quatro argumentos de função mas ao invés disso passamos apenas
dois endereços de memória e temos disponível diversos dados estatíscos disponíveis na estrutura rusage.

Economia de memória: Precisaríamos duplicar a utilização de memória para cada argumento que criássemos.

Velocidade de execução: O programa roda muito mais rápido se acessa diretamente a memória com 
ponteiros do que se ficar duplicando informação e apagando.


4. Explicar com a maior precisão possível, em um parágrafo ou mais, como main age para ler as
palavras de um arquivo. Em outras palavras, nos convença de que você realmente entende
como o for loop dessa função funciona.
R: Ele "trava" a função fgetc() num loop carregando caractere alfabético por caractere da palavra 
em cada índice do array "word" até encontrar o próximo caractere que não seja alfabético, quando ele
encontra esse ele sai do loop coloca um "\0" como último índice do array 
word e incrementa mais um no contador "words++".
Lembrando que quando o loop encontra um caractere que seja numérico OU a palavra se torne maior que
44 letras ele simplesmente termina de "consumir" a leitura de toda a palavra e zera o index novamente
fazendo com que as palavras contendo números ou excessivamente compridas sejam literalmente ignoradas.


5. Porque você acha que nós usamos fgetc para ler cada caracter de cada palavra ao vez ao
invés de fscanf com uma string formatada como "%s" para ler palavras inteiras de uma
vez? Dito de outra forma, que problemas poderiam surgir ao depender de fscanf para
realizar essa tarefa?
R: Se utilizar fscanf não há meios de saber se o caracter indesejado pertence à composição da palavra
ou não. 


6. Por que você acha que nós declaramos tantos parâmetros const em dictionary.c e
dictionary.h?
R: Para impedir que algum erro na implementação das funções load e check modificassem o conteúdo das
variáveis passadas. O parâmetro const altera o contrato estabelecido entre funções que passam entre
sí estas variáveis. Quando se utiliza const no parâmetro a função que recebe a variável pode alterar
o ponteiro, mas não pode alterar o conteúdo do array. Já quando não se utiliza o parâmetro "const"
a função que recebe a variável não pode alterar o ponteiro mas pode alterar o conteúdo do array.


7. Qual estrutura de dado(s) você usou para implementar o seu corretor ortográfico? Certifique-se
de não responder apenas "hash table", "trie", ou coisa parecida. Fale um pouco sobre o que
está dentro de cada um dos seus "nós".
R: Eu utilizei uma lista encadeada, onde cada item da lista possui um indicador booleano indicando
se é o final ou não de uma palavra e 26 nós ponteiros para a mesma estrutura chamado de filhos, onde 
cada um deles corresponde ao caracter da palavra, por exemplo: A ou a = node->son[1], B ou b = node-
->son[2], C ou c = node->son[3], etc ... Deste mode quando a função check() percorre pelo vetor de 
ponteiros e de fato o "caminho existe" e no final da palavra testada existe um node->end == true
então a palavra existe no dicionário caso contrário não.


8. Quão lento era o seu código na primeira vez que você o fez funcionar?
R: Não foi lento, pois o método escolhido é o análogo ao algoritmo de ordenação sort O(n).


9. Que tipos de alterações, se for o caso, você fez no seu código ao longo da semana (er, quintfeira), a fim de melhorar o seu desempenho?
R: Nenhum.


10. Você sente que o seu código tem alguma parte pesada que você não foi capaz de desbastar?
R: Não.
